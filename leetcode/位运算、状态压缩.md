https://leetcode-cn.com/problems/count-words-obtained-after-adding-a-letter/
## 统计追加字母可以获得的单词数

给你两个下标从 0 开始的字符串数组 startWords 和 targetWords 。每个字符串都仅由 小写英文字母 组成。

对于 targetWords 中的每个字符串，检查是否能够从 startWords 中选出一个字符串，执行一次 转换操作 ，得到的结果与当前 targetWords 字符串相等。

转换操作 如下面两步所述：

追加 任何 不存在 于当前字符串的任一小写字母到当前字符串的末尾。
例如，如果字符串为 "abc" ，那么字母 'd'、'e' 或 'y' 都可以加到该字符串末尾，但 'a' 就不行。如果追加的是 'd' ，那么结果字符串为 "abcd" 。
重排 新字符串中的字母，可以按 任意 顺序重新排布字母。
例如，"abcd" 可以重排为 "acbd"、"bacd"、"cbda"，以此类推。注意，它也可以重排为 "abcd" 自身。
找出 targetWords 中有多少字符串能够由 startWords 中的 任一 字符串执行上述转换操作获得。返回 targetWords 中这类 字符串的数目 。

注意：你仅能验证 targetWords 中的字符串是否可以由 startWords 中的某个字符串经执行操作获得。startWords  中的字符串在这一过程中 不 发生实际变更。

示例
```js
输入：startWords = ["ant","act","tack"], targetWords = ["tack","act","acti"]
输出：2
解释：
- 为了形成 targetWords[0] = "tack" ，可以选用 startWords[1] = "act" ，追加字母 'k' ，并重排 "actk" 为 "tack" 。
- startWords 中不存在可以用于获得 targetWords[1] = "act" 的字符串。
  注意 "act" 确实存在于 startWords ，但是 必须 在重排前给这个字符串追加一个字母。
- 为了形成 targetWords[2] = "acti" ，可以选用 startWords[1] = "act" ，追加字母 'i' ，并重排 "acti" 为 "acti" 自身。
```

```js
/**
 * @param {string[]} startWords
 * @param {string[]} targetWords
 * @return {number}
 */
var wordCount = function(startWords, targetWords) {
    // 思路: 位运算 状态压缩 哈希set
    // 关键代码: return s.charCodeAt() - 'a'.charCodeAt();
    // 关键代码: x |= 1 << pos(word[i]); // 让x中有 (1 左移 每个字符对应charCodeAt)
    // 关键代码:  const res = t ^ x; if (set.has(res)) { ans++; break; // 跳出

    const set = new Set();
    const getPos = (s) => {
        return s.charCodeAt() - 'a'.charCodeAt(); // - 'a'.charCodeAt() 就是 - 97 让数字小一些 'a' 97 / b'98'
    }
    // 1. 将 startWords 中的单词转换为二进制的形式存储到 set 中
    for (let word of startWords) {
        let x = 0
        //   cat 存储为 
        //     ....1.........1....1
        //         t         c    a
        for (const char of word) {
            x |= 1 << getPos(char); // 让x中有 (1 左移 每个字符对应charCodeAt)
        }
        set.add(x);
    }
    let ans = 0;
    //   2. 遍历 targetWords 的每一项 target，尝试删除其中每一个字符，看其余字符是否在 set 中出现
    for (const word of targetWords) {
        if (word.length < 2) { // 优化
            continue;
        }
        let x = 0;
        for (const char of word) {
            x |= 1 << getPos(char);
        }
        for (const v of word) {
            const t = 1 << getPos(v);//  1 << 3 就是 1000
            const ret = t ^ x; // 异或 消除某个位置的1,因为把1推过去, 1 ^ 1会变成0，正好看看剩下的是不是 set里已有的，有的话就可以组成单词
            if (set.has(ret)) {
                ans++;
                break; // 跳出
            }
        }
    }
    return ans;
};

    // 状态压缩、位运算、哈希
    //   1. 将 startWords 中的单词转换为二进制的形式存储到 set 中
    //   2. 遍历 targetWords 的每一项 target，尝试删除其中每一个字符，看其余字符是否在 set 中出现
    
    //   使用状态压缩存储和比对
    
    //   举例说明，中间省略部分使用省略号大概代替，省略部分都为 0 原理是这样：
    
    //   cat 存储为 
    //     ....1.........1....1
    //         t         c    a
        
    //   acti 存储为
    //     ....1....1....1....1
    //         t    i    c    a
        
    //   然后尝试把 acti 存储的二进制的值的每一个 1 变成 0，看它是否出现在 set 中即可
    //   比如把 i 干掉后就set.has(res)成立找到一个，ans++; break;
```
